Updated Arduino Code 

#include <WiFiNINA.h>
#include <ArduinoHttpClient.h>
#include <ArduinoJson.h>

const char* ssid = "KatherineiPhone";
const char* password = "Katherine@123";

const char* server = "172.20.10.2";
const int port = 8080;

const int pinButtonA = 8;
const int pinButtonB = 9;
const int pinButtonC = 10;

const int pinLedA = 12;
const int pinLedB = 7;
const int pinLedC = 6;

const int pinBuzzer = 3;

WiFiClient wifi;
HttpClient client = HttpClient(wifi, server, port);

// ----- Buzzer control -----
bool buzzerActive = false;
unsigned long buzzerEndTime = 0;
int buzzerPinFreq = 0;

void startBuzzer(int frequency, int duration) {
  tone(pinBuzzer, frequency);
  buzzerActive = true;
  buzzerEndTime = millis() + duration;
  buzzerPinFreq = frequency;
}

void updateBuzzer() {
  if (buzzerActive && millis() >= buzzerEndTime) {
    noTone(pinBuzzer);
    buzzerActive = false;
  }
}

// ----- Alert polling control -----
unsigned long lastAlertCheck = 0;
const unsigned long alertInterval = 60000;  // 60 seconds = 1 minute

void checkAlerts() {
  if (millis() - lastAlertCheck >= alertInterval) {
    lastAlertCheck = millis();

    String url = "/getAlerts?device_id=1";
    client.beginRequest();
    client.get(url);
    client.endRequest();
    
    int status = client.responseStatusCode();
    if (status == 200) {
      String response = client.responseBody();
      Serial.println("Alert data: " + response);

      StaticJsonDocument<200> alertDoc;
      DeserializationError error = deserializeJson(alertDoc, response);
      if (!error) {
        bool alert = alertDoc["alert"];
        int freq = alertDoc["frequency"];
        int dur = alertDoc["duration"];
        if (alert) {
          startBuzzer(freq, dur);
        }
      } else {
        Serial.println("JSON parse error");
      }
    } else {
      Serial.println("Failed to fetch alerts, status: " + String(status));
    }
  }
}

void sendMood(int mood, int ledPin) {
  StaticJsonDocument<200> jsonDoc;
  jsonDoc["device_id"] = 1;
  jsonDoc["mood"] = mood;

  String jsonData;
  serializeJson(jsonDoc, jsonData);

  Serial.print("Sending: ");
  Serial.println(jsonData);

  client.beginRequest();
  client.post("/addMood");
  client.sendHeader("Content-Type", "application/json");
  client.sendHeader("Content-Length", jsonData.length());
  client.endRequest();
  client.print(jsonData);

  int status = client.responseStatusCode();
  String response = client.responseBody();

  Serial.print("Status: ");
  Serial.println(status);
  Serial.print("Response: ");
  Serial.println(response);

  if (status == 200) {
    digitalWrite(ledPin, HIGH);
    delay(800);
    digitalWrite(ledPin, LOW);
  } else {
    Serial.println("HTTP POST failed, LED not lit.");
  }

  delay(3000);
}

// ----- Setup -----
void setup() {
  Serial.begin(9600);
  while (!Serial);

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.println("Connecting...");
  }
  Serial.println("WiFi Connected!");

  pinMode(pinButtonA, INPUT_PULLUP);
  pinMode(pinButtonB, INPUT_PULLUP);
  pinMode(pinButtonC, INPUT_PULLUP);

  pinMode(pinLedA, OUTPUT);
  pinMode(pinLedB, OUTPUT);
  pinMode(pinLedC, OUTPUT);

  pinMode(pinBuzzer, OUTPUT);
}

// ----- Main loop -----
void loop() {
  if (digitalRead(pinButtonA) == LOW) {
    Serial.println("Mood 3");
    sendMood(3, pinLedA);
  }
  else if (digitalRead(pinButtonB) == LOW) {
    Serial.println("Mood 2");
    sendMood(2, pinLedB);
  }
  else if (digitalRead(pinButtonC) == LOW) {
    Serial.println("Mood 1");
    sendMood(1, pinLedC);
  }

  updateBuzzer();

  checkAlerts();
}

----

## main.go
package main

import (
	"context"
	"io"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"goapi/internal/api/repository"
	"goapi/internal/api/server"
	"goapi/internal/api/service"
)

func NewSimpleLogger(logFile string) *log.Logger {
	file, _ := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	return log.New(io.MultiWriter(file, os.Stdout), "", log.Ldate|log.Ltime|log.Lshortfile)
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	logger := NewSimpleLogger("production.log")

	db, err := repository.NewPostgres("postgres://admin:password@localhost:5432/moodtracker")
	if err != nil {
		logger.Println("DB error:", err)
		return
	}
	// <-- ADD THIS BLOCK
	var dbName string
	err = db.QueryRow(context.Background(), "SELECT current_database()").Scan(&dbName)
	if err != nil {
		logger.Println("DB name error:", err)
	} else {
		logger.Println("Connected to DB:", dbName)
	}
	// <-- END OF BLOCK
	defer db.Close()

	moodRepo := repository.NewMoodRepository(db)
	moodService := service.NewMoodService(moodRepo)

	mux := http.NewServeMux()
	handler := server.NewArduinoHandler(moodService)
	mux.HandleFunc("/addMood", handler.HandleMood)

	srv := server.NewServer(ctx, mux, logger)
	gracefulShutdown(srv, cancel, logger)

	logger.Println("Server starting on :8080...")
	if err := srv.ListenAndServe(":8080"); err != http.ErrServerClosed {
		logger.Println("Server error:", err)
	}
}

func gracefulShutdown(s *server.Server, cancel context.CancelFunc, logger *log.Logger) {
	ch := make(chan os.Signal, 1)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		<-ch
		cancel()
		s.Shutdown()
		logger.Println("Graceful shutdown done.")
	}()
}

## repository/moodRepository.go
package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgxpool"
)

type MoodRepository struct {
	DB *pgxpool.Pool
}

func NewMoodRepository(db *pgxpool.Pool) *MoodRepository {
	return &MoodRepository{DB: db}
}

func (r *MoodRepository) InsertMood(ctx context.Context, mood int) error {
	_, err := r.DB.Exec(ctx,
		"INSERT INTO prototypedevice (entry_date, mood) VALUES (CURRENT_DATE, $1)",
		mood,
	)
	if err != nil {
		println("DB ERROR:", err.Error()) // <-- ADD THIS LINE
	}
	return err
}

## server/ handlers.go
package server

import (
	"encoding/json"
	"goapi/internal/api/service"
	"net/http"
)

type ArduinoHandler struct {
	MoodService *service.MoodService
}

func NewArduinoHandler(ms *service.MoodService) *ArduinoHandler {
	return &ArduinoHandler{MoodService: ms}
}

func (h *ArduinoHandler) HandleMood(w http.ResponseWriter, r *http.Request) {
	type MoodRequest struct {
		Mood int `json:"mood"`
	}

	var req MoodRequest
	json.NewDecoder(r.Body).Decode(&req)

	if req.Mood < 1 || req.Mood > 3 {
		http.Error(w, "invalid mood", http.StatusBadRequest)
		return
	}

	err := h.MoodService.SaveMood(r.Context(), req.Mood)
	if err != nil {
		http.Error(w, "database error", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte("OK"))
}

## server/server.go
package server

import (
	"context"
	"log"
	"net/http"
)

type Server struct {
	httpServer *http.Server
	Logger     *log.Logger
}

func NewServer(ctx context.Context, mux *http.ServeMux, logger *log.Logger) *Server {
	s := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}

	return &Server{
		httpServer: s,
		Logger:     logger,
	}
}

func (s *Server) ListenAndServe(addr string) error {
	return s.httpServer.ListenAndServe()
}

func (s *Server) Shutdown() error {
	return s.httpServer.Close()
}

## service/moodService.go
package service

import (
	"context"
	"goapi/internal/api/repository"
)

type MoodService struct {
	Repo *repository.MoodRepository
}

func NewMoodService(repo *repository.MoodRepository) *MoodService {
	return &MoodService{Repo: repo}
}

func (s *MoodService) SaveMood(ctx context.Context, mood int) error {
	return s.Repo.InsertMood(ctx, mood)
}
 
